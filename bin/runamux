#!/bin/bash

#
# █▀▄ █ █ █▄ █ ▄▀▄ █▄ ▄█ █ █ ▀▄▀
# █▀▄ ▀▄█ █ ▀█ █▀█ █ ▀ █ ▀▄█ █ █
#
#  a simple tmux session runner
#

set -u

# Get script install prefix, assuming script is ${PREFIX}/bin/runamux
PREFIX=$(cd -P "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)

readonly PREFIX
readonly LIBEXEC=${PREFIX}/libexec/runamux

# global state vars
session_name=
session_uuid=
window_name=
window_uuid=

#
# tmux command shortcuts
#

# tmux shortcut
#
t() {
  tmux "$@"
}

# tmux, silent all output
#
s() {
  t "$@" &>/dev/null
}

# tmux, silent stderr only
#
e() {
  t "$@" 2>/dev/null
}

# Shortcut to 'tmux display-message -p'
#
d() {
  e display-message -p "$@"
}

#
# Helpers
#

# Log message to stderr
#
m() {
  echo "[runamux${session_name:+ $session_name}] $*" >&2
}

# Kill pane (kills child process, not just the pane)
#
_kill() {
  local \
    id=${1:?_kill id arg required} \
    pid=${2:?_kill pid arg required}

  m "killing pane ID=$id PID=$pid"

  t set-option -pt "$id" remain-on-exit off
  t set-hook -upt "$id" pane-died

  # kill child process
  (( pid > 1 )) && kill -SIGINT "$pid" &>/dev/null

  # actually close the pane
  s kill-pane -t "$id"

  m "pane killed (ID=$id PID=$pid)"
}

# Check if there is an active session
#
_session-active() {
  [ -z "$session_uuid" ] && {
    m "ERROR: no session created"
    return 1
  }
  return 0
}

# Check if there is an active session AND window
#
_window-active() {
  _session-active || {
    return 1
  }
  [ -z "$window_uuid" ] && {
    m "ERROR: no window created"
    return 1
  }
  return 0
}

#
# Commands
#

# Get pane child process PID
#
pane-pid() {
  d -t "$1" '#{pane_pid}'
}

# Kill pane (kill child process and close pane)
#
kill-pane() {
  _window-active || return 1

  local t="$session_uuid:$window_uuid.$1"

  d -t "$t" -F '#D #{pane_pid}' | while read -r id pid; do
    _kill "$id" "$pid"
  done
}

# Kill window (kill child process of all child panes)
#
kill-window() {
  _session-active || return 1

  m "killing all panes in window '${1:?kill-window window arg required}'"

  local t="$session_uuid:$1"

  e list-panes -t "$t" -F '#D #{pane_pid}' | while read -r id pid; do
    _kill "$id" "$pid"
  done
}

# Check if current server has session named '$1'
#
has-session() {
  s has-session -t "$1"
}

# Check if last created session has window named '$1'
#
has-window() {
  _session-active || return 1
  tmux list-windows -F '#W' -t "$session_uuid" | grep -sq "^${1:?}$"
}

# Start a new detached session
#
session() {
  session_name=${1:?}
  session_uuid=
  window_name=
  window_uuid=

  m "creating session '$session_name'"

  local n=$session_name
  local t="=$n"

  has-session "$t" && {
    m "session already exists: do nothing"

    session_uuid=$(d -t "$t:" '#{session_id}') || {
      m "failed to get session id (exit status: $?)"
      session_uuid=
    }

    return 1
  }

  # create placeholder window 'session/TMP' as first window,
  # running the `pause` command (simply waits for a signal)
  session_uuid=$(e new -dn "${n}/TMP" -s "$n" -PF '#{session_id}' pause) || {
    m "failed to create session (exit status: $?)"
    session_name=
    session_uuid=
    return 1
  }

  # set RUNAMUX_PREFIX env var of our libexec scripts
  t set-environment -t "$session_uuid" RUNAMUX_PREFIX "$PREFIX"

  m "session created"
}

# Add a new window in last created session
#
window() {
  _session-active || return 1

  local \
    kill_existing=0 \
    window_exists=0

  [ "${1:?window arg required}" = -k ] && {
    kill_existing=1
    shift
  }

  m "creating window '${1:?window arg required}'"

  has-window "$1" && {
    (( !kill_existing )) && {
      m "window already exists: do nothing"
      return 1
    }

    window_exists=1
  }

  window_name=$1/TMP
  window_uuid=

  # if this is the first window created for the session,
  # simply rename the original placeholder 'session/TMP'
  # window to 'window/TMP', as a first pane placeholder
  if has-window "$session_name/TMP"; then
    local t="$session_uuid:=$session_name/TMP"

    t rename-window -t "$t" "$window_name" || {
      m "failed to rename placeholder session window (exit status: $?)"
      window_name=
      return 1
    }
  else
    # otherwise this is the 2nd window onwards, create the
    # placeholder pane 'window/TMP', with the `pause` command
    t new-window -dn "$window_name" -t "$session_uuid:" pause || {
      m "failed to create new window (exit status: $?)"
      window_name=
      return 1
    }
  fi

  local t="$session_uuid:=$window_name"

  window_uuid=$(d -t "$t" '#{window_id}') || {
    m "failed to get window id (exit status: $?)"
    window_name=
    window_uuid=
    return 1
  }

  # kill existing window, if any
  if (( window_exists )); then
    kill-window "=$1"
  fi

  # set remain-on-exit on window so that any panes created that
  # exited early, will remain for examining
  t set-option -wt "$session_uuid:$window_uuid" remain-on-exit on

  m "window '$1' created"
}

# Create new pane (horizontal split)
#
pane() {
  _window-active || return 1

  [ -z "$window_name" ] && {
    m "ERROR: window active but has no name (bug?)"
    return 1
  }

  local \
    target="$session_uuid:$window_uuid" \
    placeholder='' \
    pane

  m "creating pane '$*'"

  # if this is the first pane created for the window,
  # a 'window/TMP' pane was already created, we don't
  # need this pane anymore. save its pane_id so we can
  # close it *AFTER* creating the new pane
  [[ "$window_name" = */TMP ]] && {
    placeholder=$(d -t "$session_uuid:=$window_name" '#{pane_id}')
  }

  # split the window to create the pane
  pane=$(e split-window -Pht "$target" -F '#D' "$@") || {
    m "failed to add pane (exit status: $?)"
    return 1
  }

  t set-hook -pt "$pane" pane-died "run -b '$LIBEXEC/notify-died $pane'"
  t set-hook -pt "$pane" alert-bell "run -b '$LIBEXEC/notify-bell $pane'"

  # close the original 'window/TMP' placeholder pane
  #
  # NOTE: we could just `tmux respawn-pane` with the new command,
  # but in doing so it seems tmux doesn't properly send SIGINT
  # to the child process.
  [ "$placeholder" ] && {
    m "closing placeholder pane '$window_name' (ID=$placeholder)"
    window_name=${window_name%%/TMP}
    kill-pane "$placeholder"
    t rename-window -t "$session_uuid:$window_uuid" "$window_name"
  }

  # auto apply tiled layout
  t select-layout -t "$session_uuid:$window_uuid" tiled

  m "pane '$1' created"
}

#
# Usage and Version
#

# Print usage
#
usage() {
  echo "Usage: $0 CONFIG
Start a tmux session defined in the file CONFIG.

Options:

Argument CONFIG can be a path to a file as-is, the base
name of a .conf file, or a CONFIG.conf file in the
runamux config directory, first file found in that order
is used.

Runamux config directory is \$XDG_CONFIG_HOME/runamux.

The config file must be a Bash script. These functions are
available to start sessions, windows and panes:

  session NAME      Start new detached session.

  window [-k] NAME  Add a window to last created session.
                    If '-k' option passed, and a window
                    with same name exists, kill it.

  pane COMMAND...   Add a pane and run COMMAND in it.

Environment:

  XDG_CONFIG_HOME   Defaults to \$HOME/.config

Report bugs at https://github.com/241m/runamux"
}

# Version and author
#
version() {
  echo "$(basename "$0") 0.1.0"
  echo
  echo "Written by Zaim Bakar."
}

#
# main()
#

if [ -z "$1" ]; then
  usage
  exit 1
fi

case "$1" in
  -h|--help)
    usage
    exit
    ;;
  --version)
    version
    exit
esac

# some sanity checks
for f in $LIBEXEC/notify-died $LIBEXEC/notify-bell; do
  if [ ! -f "$f" ]; then
    echo "Required libexec script not found: $f"
    exit 1
  fi
done

for f in $1 $1.conf "${XDG_CONFIG_HOME:-$HOME/.config}/runamux/$1.conf"; do
  # shellcheck source=/dev/null
  if [ -f "$f" ]; then
    . "$f"
    break
  fi
done
